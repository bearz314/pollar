<!DOCTYPE html>
<html>
<head>
    <title>Live Poll</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO" crossorigin="anonymous"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        #chart {
            margin: 0px;
            height: 60vh;
            width: 100%; /* Responsive */
            overflow: hidden;
        }
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        .bar {
            fill: gray;
            margin: 2px;
        }
    </style>

</head>
<body>
    <div id="status">Class is not running.</div>
    <h1 id="question"></h1>
    <div id="options"></div>

    <div id="chart"></div>
    <div id="results" style="display:none;">
        <h2>Results</h2>
        <div id="resultText"></div>
        
    </div>
    <div id="final_results" style="display:none;">
        <h2>Final Results</h2>
        <div id="finalResultText"></div>
    </div>

    <script>
        const socket = io('http://127.0.0.1:5000');

        let voted_state = false;
        let voted_poll_token_state = "";

        socket.on('connect', function() {
            // on connect, expected events 'myvote' followed by 'update'. The below will run only after.
            console.log('Websocket now on standby');
        });

        socket.on('disconnect', function() {
            UI_clear();
            document.getElementById('status').textContent = "Class is not running.";
            console.log('Disconnected');
        });

        socket.on('invalid', function() {
            console.log('Invalid request');
        });

        socket.on('myvote', function(data) {
            voted_state = data.voted;
            voted_poll_token_state = data.voted_poll_token;
            // data.myvote unused for now
            if (voted_state) {
                console.log(`myvote: Restored voted state for poll token ${voted_poll_token_state}`);
            }
        });

        socket.on('update', function(data) {

            console.log('Update:');
            console.log(data);

            if (data.state == 'STARTING_SOON') {
                UI_clear();
                document.getElementById('status').textContent = "Class is starting soon...";
            } else {
                document.getElementById('status').textContent = data.state;
            }

            switch (data.state) {
                case 'STARTING_SOON':
                    // Show nothing
                    UI_clear();
                    break;
                case 'POLL_OPENS':
                    if (voted_poll_token_state !== data.poll_token) {
                        voted_state = false;
                    }
                    if (voted_state) {
                        // Show question/votes
                        console.log("Poll already voted.")
                        UI_show_votes(data);
                    } else {
                        // Show question/options
                        document.getElementById('question').textContent = data.question;
                        const options = data.options.map((option, index) => 
                            `<button onclick="vote(${data.poll_token},${index})">${option}</button>`
                        ).join('<br />');
                        document.getElementById('options').innerHTML = options;
                        document.getElementById('results').style.display = 'none';
                        document.getElementById('final_results').style.display = 'none';
                    }
                    break;
                case 'POLL_CLOSES':
                    // Show question/votes
                    UI_show_votes(data);
                    break;
                case 'POLL_ANSWER':
                    // Show question/options+votes/answer
                    document.getElementById('question').textContent = data.question;
                    const finalResultText = data.results.map((votes, index) => 
                        `<b>${data.options[index]}</b>: ${votes} vote(s) ${index === data.correct_answer ? '(Correct)' : ''}`
                    ).join('<br>');
                    document.getElementById('finalResultText').innerHTML = finalResultText;
                    document.getElementById('final_results').style.display = 'block';
                    document.getElementById('results').style.display = 'none';
                    break;
            }
        });

        function vote(pollToken, optionIndex) {
            voted_state = true;
            voted_poll_token_state = pollToken;
            socket.emit('vote', { poll_token: pollToken, option_index: optionIndex });
            // expects 'update' event
            console.log(`Voted ${optionIndex} with token ${pollToken}!`);
        }

        function UI_clear() {
            document.getElementById('question').textContent = '';
            document.getElementById('options').innerHTML = '';
            document.getElementById('results').style.display = 'none';
            document.getElementById('final_results').style.display = 'none';
        }
        function UI_show_votes(data) {
            UI_clear();
            document.getElementById('resultText').innerHTML = data.anonymised_votes;
            document.getElementById('results').style.display = 'block';
            if (data.response_editable && data.state=='POLL_OPENS') {
                document.getElementById('resultText').innerHTML += `<button onclick="voted_state=false;socket.emit('getstate');">Edit</button>`;
            }
            updateChart(data.anonymised_votes);
        }



        // Function to get the dynamic width and height
        function getChartDimensions() {
            const chartDiv = document.getElementById('chart');
            return {
                width: chartDiv.clientWidth,
                height: chartDiv.clientHeight
            };
        }

        
        
        // Create the SVG element with dynamic viewBox
        const chartMargin = {top: 20, right: 30, bottom: 10, left: 30};
        let svg = d3.select("#chart").append("svg");
        let chartGroup = svg.append("g")
                            .attr("transform", `translate(${chartMargin.left},${chartMargin.top})`);

        // Function to update the bar chart with new data
        function updateChart(values) {
            // constants
            const transitionDuration = 750;
            const textPadding = 5;
            const labelYOffset = 4;

            // Graphable area is graph width minus text width
            const chartDimensions = getChartDimensions();
            
            // Find out the length of the longest text
            let tempTextGroup = svg.append("g").attr("opacity", 0);
            // append temporary text to measure
            let tempTexts = tempTextGroup.selectAll(".temp-text")
                .data(values)
                .enter().append("text")
                .attr("class", "temp-text")
                .attr("x",0)
                .text(d => d);
            // measure text widths and find the maximum width
            let maxTextWidth = d3.max(tempTexts.nodes(), node => node.getComputedTextLength());
            tempTextGroup.remove();

            // Graphable area for bars (excluding texts)
            const width = chartDimensions.width - chartMargin.left - chartMargin.right - maxTextWidth;
            const height = chartDimensions.height - chartMargin.top - chartMargin.bottom;

            // Update viewBox to new dimensions for responsiveness
            svg.attr("viewBox", `0 0 ${chartDimensions.width} ${chartDimensions.height}`);

            let data = values.map((value, index) => ({ name: index, value }));

            // Sort data according to value
            data.sort((a, b) => d3.descending(a.value, b.value));

            // Update the scales
            const x = d3.scaleLinear()
                        .domain([0, d3.max(data, d => d.value)])
                        .range([0, width]);
            
            const y = d3.scaleBand()
                        .domain(data.map(d => d.name))
                        .range([0, height])
                        .padding(0.1);

            // Join the data to rects (bars)
            const bars = chartGroup.selectAll(".bar")
                                   .data(data, d => d.name);

            bars.enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", 0)
                .attr("y", d => y(d.name))
                .attr("height", y.bandwidth())
                .merge(bars)
                // animation for all change in state
                .transition().duration(transitionDuration)
                .attr("x", 0)
                .attr("y", d => y(d.name))
                .attr("width", d => x(d.value));

            bars.exit()
                .transition().duration(transitionDuration)
                .attr("width", 0)
                .remove();

            // Join the data to text labels
            const labels = chartGroup.selectAll(".label")
                                     .data(data, d => d.name);

            labels.enter()
                .append("text")
                .attr("class", "label")
                .attr("x", d => x(d.value) + 5)
                .attr("y", d => y(d.name) + y.bandwidth() / 2 + labelYOffset)
                .text(d => d.value)
                .attr("text-anchor", "start")
                .merge(labels)
                // animation for all change in state
                .transition().duration(750)
                .attr("x", d => x(d.value) + 5)
                .attr("y", d => y(d.name) + y.bandwidth() / 2 + labelYOffset)
                .text(d => d.value);
            
            labels.exit()
                .transition().duration(750)
                .attr("x", 0)
                .remove();
        }

    </script>
</body>
</html>
